A quoi sert SFI?

SFI permet à une application d'intégrer dans son espace mémoire d'autres programmes auxquels on ne fait pas confiance sans que ces derniers puissent en compromettre le fonctionnement.
Ces protections sont implémentées de manière logicielle en modifiant et en vérifiant que le code "étranger" suivent certaines propriétés de sécurité.

- Le programme de non-confiance est alloué une zone mémoire contigüe dans l'espace du programme hôte
- On vérifie que tout saut direct du programme reste dans la mémoire dédiée par analyse statique durant la génération de code sinon l'instruction est modifiée ou l'application est rejetée
- Les instructions non fiables sont masquées pour assurer que le flux de contrôle reste dans la mémoire dédiée (return, indirect jump), masquage des bits de poids forts
- Alignement des adresses appelées pour éviter de sauter au milieu d'une instruction (bits de poids faibles) sur les instructions accédant à la mémoire dynamiquement
- Seules les instructions qui ont été vérifiées peuvent être exécutées
- Toutes les écritures (parfois on restreint aussi les lectures) dans la mémoire sont isolées dans la mémoire dédiées

Pour vérifier les accès mémoires il est nécessaire que l'emplacement de la mémoire réservée aux données et au code soit connue du compilateur et du vérificateur
Généralement la zone mémoire dédiée la taille de la région est une puissance de deux et l'adresse de départ est aussi une puissance de deux. Cette propriété nous permet d'utiliser des opérations arithmétiques sur les bits beaucoup plus efficaces


Structure de SFI

1.Générateur de code
	Prend un programme quelconque et le modifie afin qu'il soit conforme aux exigences de sécurité sans changer la sémantique de ce dernier?
	Vérifie que les adresses statiques sont dans le domaine réservé sinon modifie ou rejette le programme
	Certaines opérations ne sont pas vérifiables statiquement, par exemple un saut vers une adresse avec un biais constant et un pointeur inconnu
	Génération d'un code assembleur qui injecte dans le code les opérations de sandbox et d'alignements
	Le langage sandboxé est généré depuis l'assembleur.
	Ensuite il passe par un assembleur pour devenir un binaire sandboxé


2.Vérifieur de code
	Récupère un binaire le désassemble et vérifie qu'il satisfait certains invariants structurels
	Vérifie que le programme suit les propriétés énoncées au-dessus, si la vérification n'aboutit pas le programme est rejeté ou remodifié
	Cette étape s'effectue sur le binaire juste avant que le code soit chargé en mémoire
	Tout programme accepté par le vérificateur suit la politique établie mais tout programme suivant la politique ne sera pas forcément accepté

Dans la structure le générateur de code n'a pas besoin d'être du code de confiance seul le vérifieur doit impérativement l'être.
De cette manière le SFI a une base de code de confiance réduite ce qui est un avantage.

Celle-ci est l'approche classique mais pour avoir la garantie qu'un code vérifie ces propriétés on a 3 possibilités:
- Compiler avec un compilateur certifié
- Vérificateur de confiance
- Code avec preuve vérifiable


Dans Wahbe on utilise des registres dédiés, de ce fait on a pas besoin de se préoccuper des instructions qui pourraient sauter la vérification. En effet le vérifieur va seulement s'assurer qu'à chaque fois qu'un registre dédié va être utilisé celui-ci aura les bits de poids forts correspondant à la mémoire réservée. 
L'approche suppose un processeur RISC où toutes les instructions sont de la même taille, en l'occurrence 4 bytes de ce fait on suppose un alignement sur cette valeur des instructions et des sauts

Pittsfield, en CISC les instructions n'auront pas forcément une taille unique, on va imposer des paquets d'une valeur constante de 16 byte et tout saut sera forcément en direction d'une adresse étant un multiple de 128 => De ce fait on a plus besoin d'un registre dédié


PSFI

N'utilise pas de vérifieur
Transforme le langage intermédiaire Cminor en un Cminor sandboxé, ensuite la preuve de correctness de CompCert garantit que les propriétés de sécurités introduites sont conservées.
Le Cminor sandboxé est sûr dans le sens de SFI mais également sûr par rapport à la sémantique opérationnelle de Cminor.
=> Un programme est sain si lors de son exécution il n'atteint jamais un état qui n'a pas de sens au niveau de la sémantique opérationnelle
le cminor sandboxé garantit deux propriétés
	- Sûreté du programme/SFI, le programme transformé respecte les règles de SFI
	- Correctness, toute exécution du programme source correspond à une unique exécution du programme transformé avec le même comportement observable. Les programmes non sûrs seront transformés dans un programme sain au comportement arbitraire

Respecte le rôle de SFI, tout programme même non sûrs est transformé en un programme sûr et dont la compilation gardera ces propriétés
En plus de la SFI, PSFI est portable sur les architectures et garde une petite base de code sûr

Toutes ces propriétés impliquent qu'il est possible de garantir les exigences de sécurité de SFI au niveau de Cminor, tout cela dépend du contrôle qu'on a entre la représentation abstraite de la mémoire dans CompCert et son comportement réel, les blocs mémoires sont distincts par construction on peut restreindre les pointeurs dans ces blocs

Dans ces travaux on présente une méthode mais également un prototype avec une spec mécanisée et une preuve mécanisée qui garantit la soundness des opérations sur la mémoire du prototype. Ils décrivent comment prouver que le prototype ne change pas le comportement d'un programme déjà sûr. Manque une preuve mécanisé de la sécurite du langage assembleur du prototype fonctionnant avec CompCert


III. Au niveau de compCert la mémoire a une représentation abstraite ce qui est avantageurx pour pouvoir appliquer des optimisations. 
	La mémoire est représenté par des blocs de taille finie et por désigner un emplacement on utilise un numéro de bloc et un offset. Le but est de contenir toutes les données SFI dans un bloc et d'y mapper tous les accès mémoires potentiellement dangereux par masquage

Lors des transformations SFI tous les load et store sont dans la région SFI. Change l'emplacement du tas et déplace la pile vers une shadow stack
Ensuite le Cminor SFI-safe est ensuite compilé et garde la pté suivante. Les load/store dans SFI

SFi provient de 
1) La première étape produit des programmes Cminor sains
2) Cminor SFI n'alloue pas de mémoire hors de SFI
3) Deux manière d'allouer de la mémoire dans CompCert: malloc ou stack frame
4) La préservation de la sémantique de CompCert signifie qu'il n'introduira pas de nouveaux malloc. De plus par les ptés précédentes le programme n'a pas pu sortir de sa mémoire car stack et psfiMalloc

Avantages
- Pas bbesoin de vérifieur pour chaque architecture
- Les transformations à plus haut niveau permettent une analyse plus simple des invariants de SFI
- Les optimisations du compileur sont encore effectives le code final sera peut-être plus performant

Cminor
Cminor est le langage de plus bas-niveau qui ne nécessite pas d'analyse spécifique à une architecture, c'est une représentation intermédiaire donc on peut se débrouiller pour avoir du Cminor à partir de la plupart des langages de haut niveau. Une représentation de plus haut niveau aurait introduit des dépendances par rapport au langage source. C'est déjà une cible de plusieurs autres travaux pour compiler le code source

Cminor est typeless, ces variables temporaires n'ont pas vraiment de type, de ce fait la première passe est un inféreur de type for les tempo int/float. On utilisera ces informations pour réecrire des expressions qui sont potentiellement bloquantes
Cminor peut appeler des fct internes et externes, les externes sont simplement prototypées

On crée des axiomes pour le masquage a des fins de preuve
